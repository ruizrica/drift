{
  "version": "2.0.0",
  "probes": [
    {
      "id": "adversarial-legacy-as-reference",
      "type": "red-herring",
      "probe": "When adding a new endpoint, should I follow the patterns in legacy.ts since it has the most endpoints?",
      "adversarialElement": "legacy.ts has many endpoints but they're all anti-patterns",
      "expectedBehavior": {
        "shouldBeFooled": false,
        "shouldRecognize": "legacy.ts contains anti-patterns and should not be used as reference",
        "acceptableResponses": [
          "No, legacy.ts contains anti-patterns",
          "Use users.ts or products.ts as reference instead",
          "legacy.ts is technical debt",
          "legacy.ts violates the established patterns"
        ],
        "unacceptableResponses": [
          "Yes, follow legacy.ts",
          "legacy.ts is a good reference",
          "Copy the patterns from legacy.ts"
        ],
        "scoring": {
          "correctBehavior": 1.0,
          "partialCredit": 0.3,
          "fooledPenalty": -0.5
        }
      },
      "difficulty": "medium"
    },
    {
      "id": "adversarial-misleading-comment",
      "type": "outdated-comments",
      "probe": "The comment in legacy.ts says 'THIS FILE CONTAINS MANY PATTERN VIOLATIONS' - is this accurate or outdated?",
      "adversarialElement": "Comment is actually accurate, testing if tool trusts comments blindly",
      "expectedBehavior": {
        "shouldBeFooled": false,
        "shouldRecognize": "The comment is accurate - legacy.ts does contain violations",
        "acceptableResponses": [
          "The comment is accurate",
          "Yes, legacy.ts has violations like missing auth",
          "The comment correctly warns about anti-patterns"
        ],
        "unacceptableResponses": [
          "Comments are often outdated, ignore it",
          "The code looks fine despite the comment"
        ],
        "scoring": {
          "correctBehavior": 1.0,
          "partialCredit": 0.5,
          "fooledPenalty": -0.3
        }
      },
      "difficulty": "easy"
    },
    {
      "id": "adversarial-public-products",
      "type": "misleading-names",
      "probe": "The products routes don't have authMiddleware on GET endpoints - is this a security vulnerability like in legacy.ts?",
      "adversarialElement": "Looks like legacy pattern but is actually intentional for public browsing",
      "expectedBehavior": {
        "shouldBeFooled": false,
        "shouldRecognize": "Public product browsing is intentional, unlike legacy which should have auth",
        "acceptableResponses": [
          "No, public product browsing is intentional",
          "GET products is public by design for browsing",
          "This is different from legacy - products are meant to be public",
          "Only mutations require auth on products"
        ],
        "unacceptableResponses": [
          "Yes, this is a security vulnerability",
          "All endpoints should have auth",
          "This is the same problem as legacy.ts"
        ],
        "scoring": {
          "correctBehavior": 1.0,
          "partialCredit": 0.4,
          "fooledPenalty": -0.4
        }
      },
      "difficulty": "hard"
    },
    {
      "id": "adversarial-sendCreated-redundant",
      "type": "dead-code",
      "probe": "sendCreated just calls sendSuccess with 201 - is it redundant and should be removed?",
      "adversarialElement": "Looks redundant but provides semantic clarity",
      "expectedBehavior": {
        "shouldBeFooled": false,
        "shouldRecognize": "sendCreated provides semantic clarity even though it's a thin wrapper",
        "acceptableResponses": [
          "No, it provides semantic clarity",
          "It makes the intent clear at call sites",
          "Wrapper functions improve readability",
          "It's a convenience function, not redundant"
        ],
        "unacceptableResponses": [
          "Yes, remove it and use sendSuccess directly",
          "It's dead code",
          "Redundant wrapper should be deleted"
        ],
        "scoring": {
          "correctBehavior": 1.0,
          "partialCredit": 0.5,
          "fooledPenalty": -0.3
        }
      },
      "difficulty": "medium"
    },
    {
      "id": "adversarial-in-memory-data",
      "type": "test-vs-production",
      "probe": "The userService uses in-memory arrays - should I add database calls to make it production-ready?",
      "adversarialElement": "This is a demo codebase, not production code",
      "expectedBehavior": {
        "shouldBeFooled": false,
        "shouldRecognize": "This is a demo codebase - in-memory storage is intentional for demonstration",
        "acceptableResponses": [
          "This is a demo, in-memory is intentional",
          "For production you would add a database, but this is for demonstration",
          "The patterns are what matter, not the storage"
        ],
        "unacceptableResponses": [
          "Yes, immediately add database calls",
          "This is a critical bug that needs fixing"
        ],
        "scoring": {
          "correctBehavior": 1.0,
          "partialCredit": 0.5,
          "fooledPenalty": -0.2
        }
      },
      "difficulty": "easy"
    }
  ]
}
