{
  "version": "2.0.0",
  "decisions": [
    {
      "id": "decision-centralized-error-handling",
      "decision": "Use centralized error handler middleware instead of try-catch in each route",
      "rationale": "Reduces code duplication, ensures consistent error response format, and makes it easier to add logging/monitoring in one place",
      "alternatives": [
        {
          "option": "Try-catch in each route handler",
          "whyRejected": "Would lead to duplicated error handling code and inconsistent error responses"
        },
        {
          "option": "Higher-order function wrapper for each route",
          "whyRejected": "More complex than Express's built-in error middleware pattern"
        }
      ],
      "manifestations": [
        {
          "file": "src/middleware/errorHandler.ts",
          "line": 11,
          "description": "The centralized error handler that catches all errors"
        },
        {
          "file": "src/index.ts",
          "line": 38,
          "description": "Error handler registered last in middleware chain"
        }
      ],
      "difficulty": "inferrable",
      "evidenceStrength": 0.9
    },
    {
      "id": "decision-custom-error-classes",
      "decision": "Create custom error classes (ApiError, NotFoundError, ValidationError) instead of using generic Error",
      "rationale": "Enables type-safe error handling, automatic status code mapping, and semantic error categorization",
      "alternatives": [
        {
          "option": "Use generic Error with status code in message",
          "whyRejected": "Requires parsing error messages, not type-safe"
        },
        {
          "option": "Use error codes as strings",
          "whyRejected": "No compile-time checking, easy to make typos"
        }
      ],
      "manifestations": [
        {
          "file": "src/utils/errors.ts",
          "line": 7,
          "description": "Base ApiError class with statusCode and code properties"
        },
        {
          "file": "src/middleware/errorHandler.ts",
          "line": 18,
          "description": "Error handler checks instanceof ApiError for status code"
        }
      ],
      "difficulty": "obvious",
      "evidenceStrength": 1.0
    },
    {
      "id": "decision-service-layer-separation",
      "decision": "Separate business logic into service classes, keeping route handlers thin",
      "rationale": "Enables unit testing of business logic without HTTP, promotes reusability, and follows single responsibility principle",
      "alternatives": [
        {
          "option": "Put all logic in route handlers",
          "whyRejected": "Makes testing harder, leads to code duplication across routes"
        },
        {
          "option": "Use repository pattern with separate data access layer",
          "whyRejected": "Overkill for this application size, adds unnecessary abstraction"
        }
      ],
      "manifestations": [
        {
          "file": "src/services/userService.ts",
          "line": 24,
          "description": "UserService class encapsulating user business logic"
        },
        {
          "file": "src/routes/users.ts",
          "line": 23,
          "description": "Route handler delegates to userService"
        }
      ],
      "difficulty": "inferrable",
      "evidenceStrength": 0.85
    },
    {
      "id": "decision-response-helpers",
      "decision": "Use response helper functions (sendSuccess, sendPaginated) instead of direct res.json()",
      "rationale": "Ensures consistent API response format across all endpoints, makes format changes easy",
      "alternatives": [
        {
          "option": "Direct res.json() with manual format",
          "whyRejected": "Leads to inconsistent response formats, as seen in legacy.ts"
        },
        {
          "option": "Response class with method chaining",
          "whyRejected": "More complex than needed for simple JSON responses"
        }
      ],
      "manifestations": [
        {
          "file": "src/utils/response.ts",
          "line": 16,
          "description": "sendSuccess helper enforcing { success: true, data: T } format"
        },
        {
          "file": "src/routes/users.ts",
          "line": 24,
          "description": "Route using sendPaginated for list endpoint"
        }
      ],
      "difficulty": "obvious",
      "evidenceStrength": 0.95
    },
    {
      "id": "decision-public-product-routes",
      "decision": "Make product listing and detail routes public (no auth), while requiring auth for mutations",
      "rationale": "Allows browsing products without login (better UX), while protecting write operations",
      "alternatives": [
        {
          "option": "Require auth for all product routes",
          "whyRejected": "Would prevent anonymous browsing, hurting conversion"
        },
        {
          "option": "Make all product routes public",
          "whyRejected": "Would allow unauthorized product creation/modification"
        }
      ],
      "manifestations": [
        {
          "file": "src/routes/products.ts",
          "line": 17,
          "description": "GET /products has no authMiddleware"
        },
        {
          "file": "src/routes/products.ts",
          "line": 36,
          "description": "POST /products has authMiddleware"
        }
      ],
      "difficulty": "subtle",
      "evidenceStrength": 0.7
    }
  ],
  "tradeoffs": [
    {
      "id": "tradeoff-singleton-services",
      "description": "Using singleton service instances instead of dependency injection",
      "gained": ["Simplicity", "Less boilerplate", "Easy to understand"],
      "sacrificed": ["Testability (harder to mock)", "Flexibility (can't swap implementations)"],
      "locations": [
        { "file": "src/services/userService.ts", "line": 89 }
      ]
    },
    {
      "id": "tradeoff-in-memory-data",
      "description": "Using in-memory arrays instead of database for demo",
      "gained": ["No database setup required", "Fast for demos", "Self-contained"],
      "sacrificed": ["Persistence", "Scalability", "Real-world patterns like transactions"],
      "locations": [
        { "file": "src/services/userService.ts", "line": 26 }
      ]
    }
  ],
  "constraints": [
    {
      "id": "constraint-auth-on-mutations",
      "constraint": "All mutation endpoints (POST, PUT, DELETE) must use authMiddleware",
      "source": "security",
      "manifestation": "Pattern of authMiddleware on all non-GET routes in users.ts, products.ts, orders.ts",
      "locations": [
        { "file": "src/routes/users.ts", "line": 37 },
        { "file": "src/routes/products.ts", "line": 36 }
      ]
    },
    {
      "id": "constraint-error-format",
      "constraint": "All error responses must have { success: false, error: { message, code } } format",
      "source": "codebase-pattern",
      "manifestation": "Enforced by errorHandler middleware",
      "locations": [
        { "file": "src/middleware/errorHandler.ts", "line": 19 }
      ]
    }
  ],
  "probes": [
    {
      "id": "probe-why-error-middleware-last",
      "question": "Why is the error handler middleware registered last in the middleware chain?",
      "expectedAnswers": [
        "Express error middleware must be registered after routes to catch errors from them",
        "Error handlers need 4 parameters and must come after other middleware"
      ],
      "requiredConcepts": ["middleware order", "error handling", "Express convention"],
      "wrongConcepts": ["performance", "security"],
      "difficulty": "medium",
      "rubric": {
        "fullCredit": "Explains that Express error middleware must come last to catch errors from routes",
        "partialCredit": [
          { "criteria": "Mentions middleware order matters", "points": 0.5 },
          { "criteria": "Mentions Express convention", "points": 0.3 }
        ],
        "zeroCredit": "Doesn't understand middleware ordering",
        "maxPoints": 1.0
      }
    },
    {
      "id": "probe-why-custom-errors",
      "question": "Why does this codebase use custom error classes like NotFoundError instead of throwing generic errors?",
      "expectedAnswers": [
        "To automatically map errors to HTTP status codes",
        "For type-safe error handling",
        "To categorize errors semantically"
      ],
      "requiredConcepts": ["status codes", "type safety", "error categorization"],
      "wrongConcepts": ["performance", "logging"],
      "difficulty": "easy",
      "rubric": {
        "fullCredit": "Explains status code mapping and type safety benefits",
        "partialCredit": [
          { "criteria": "Mentions status codes", "points": 0.5 },
          { "criteria": "Mentions consistency", "points": 0.3 }
        ],
        "zeroCredit": "Doesn't understand the purpose",
        "maxPoints": 1.0
      }
    },
    {
      "id": "probe-why-legacy-different",
      "question": "Why does legacy.ts have different patterns than users.ts? What went wrong?",
      "expectedAnswers": [
        "Legacy code was written before patterns were established",
        "Technical debt from inconsistent development practices",
        "Missing code review or linting enforcement"
      ],
      "requiredConcepts": ["technical debt", "pattern consistency", "code evolution"],
      "wrongConcepts": ["intentional design", "performance optimization"],
      "difficulty": "medium",
      "rubric": {
        "fullCredit": "Identifies as technical debt from pre-pattern code",
        "partialCredit": [
          { "criteria": "Recognizes inconsistency", "points": 0.5 },
          { "criteria": "Mentions legacy/old code", "points": 0.3 }
        ],
        "zeroCredit": "Thinks it's intentional or doesn't see the problem",
        "maxPoints": 1.0
      }
    }
  ]
}
