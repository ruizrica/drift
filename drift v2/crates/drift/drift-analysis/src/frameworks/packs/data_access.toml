[framework]
name = "data-access-patterns"
display_name = "Data Access Patterns"
languages = ["typescript", "javascript", "python", "java", "csharp", "go", "rust", "ruby", "php", "kotlin"]

# --- Transaction Patterns ---

[[patterns]]
id = "DA-TX-BLOCK-001"
category = "data_access"
description = "Transaction block"
sub_type = "transaction"
confidence = 0.85
[patterns.match]
content_patterns = [
    "(?i)\\$transaction\\s*\\(", "(?i)\\.transaction\\s*\\(",
    "(?i)beginTransaction\\s*\\(", "(?i)startTransaction\\s*\\(",
    "(?i)withTransaction\\s*\\(", "(?i)session\\.begin\\s*\\(",
    "(?i)@transaction\\.atomic", "(?i)transaction\\.atomic\\s*\\(",
    "(?i)BEGIN\\s+TRANSACTION", "(?i)START\\s+TRANSACTION",
]
[patterns.learn]
group_by = "sub_type"
signal = "convention"

[[patterns]]
id = "DA-TX-DECORATOR-001"
category = "data_access"
description = "Transaction decorator/annotation"
sub_type = "transaction"
confidence = 0.90
[patterns.match]
decorators = ["Transaction", "Transactional", "transaction.atomic"]

[[patterns]]
id = "DA-TX-COMMIT-001"
category = "data_access"
description = "Manual commit/rollback"
sub_type = "transaction"
confidence = 0.80
[patterns.match]
calls = ["commit", "rollback", "savepoint"]

# --- Repository Pattern ---

[[patterns]]
id = "DA-REPO-CLASS-001"
category = "data_access"
description = "Repository class definition"
sub_type = "repository"
confidence = 0.85
[patterns.match]
class_names = ["(?i).*Repository$", "(?i).*Repo$"]
[patterns.learn]
group_by = "sub_type"
signal = "convention"

[[patterns]]
id = "DA-REPO-INTERFACE-001"
category = "data_access"
description = "Repository interface/trait"
sub_type = "repository"
confidence = 0.85
[patterns.match]
content_patterns = [
    "(?i)interface\\s+\\w*Repository",
    "(?i)trait\\s+\\w*Repository",
    "(?i)abstract\\s+class\\s+\\w*Repository",
]

# --- DTO Patterns ---

[[patterns]]
id = "DA-DTO-CLASS-001"
category = "data_access"
description = "Data Transfer Object"
sub_type = "dto"
confidence = 0.80
[patterns.match]
class_names = ["(?i).*DTO$", "(?i).*Dto$", "(?i).*Request$", "(?i).*Response$", "(?i).*ViewModel$"]
[patterns.learn]
group_by = "sub_type"
signal = "convention"

# --- Connection Pooling ---

[[patterns]]
id = "DA-POOL-001"
category = "data_access"
description = "Connection pool configuration"
sub_type = "connection-pool"
confidence = 0.85
[patterns.match]
content_patterns = [
    "(?i)pool\\s*[=:]\\s*\\{", "(?i)poolSize\\s*[=:]",
    "(?i)pool_size\\s*=", "(?i)max_connections\\s*=",
    "(?i)connectionPool", "(?i)connection_pool",
    "(?i)createPool\\s*\\(", "(?i)GenericPool",
]

# --- N+1 Query Detection ---

[[patterns]]
id = "DA-NPLUS1-EAGER-001"
category = "data_access"
description = "Eager loading to prevent N+1"
sub_type = "n-plus-one"
confidence = 0.80
[patterns.match]
content_patterns = [
    "(?i)\\.include\\s*\\(", "(?i)\\.Include\\s*\\(",
    "(?i)\\.eager\\s*\\(", "(?i)select_related\\s*\\(",
    "(?i)prefetch_related\\s*\\(", "(?i)\\.joins\\s*\\(",
    "(?i)\\.preload\\s*\\(", "(?i)\\.with\\s*\\(['\"]",
    "(?i)Preload\\s*\\(", "(?i)\\.Eager\\s*\\(",
]

# --- Query Patterns ---

[[patterns]]
id = "DA-QUERY-BUILDER-001"
category = "data_access"
description = "Query builder usage"
sub_type = "query"
confidence = 0.80
cwe_ids = [89]
[patterns.match]
content_patterns = [
    "(?i)createQueryBuilder\\s*\\(",
    "(?i)\\.where\\s*\\(.*\\)\\.and",
    "(?i)\\.select\\s*\\(.*\\)\\.from",
    "(?i)QueryBuilder",
]

# --- Validation at Data Layer ---

[[patterns]]
id = "DA-VALIDATE-001"
category = "data_access"
description = "Data layer validation"
sub_type = "validation"
confidence = 0.80
[patterns.match]
content_patterns = [
    "(?i)@Column\\s*\\(.*nullable",
    "(?i)@NotNull", "(?i)@NotBlank", "(?i)@NotEmpty",
    "(?i)validates\\s+:", "(?i)validate_presence_of",
    "(?i)@IsNotEmpty", "(?i)@IsString", "(?i)@IsNumber",
]

# --- Sensitive Field Detection ---

[[patterns]]
id = "DA-SENSITIVE-001"
category = "data_access"
description = "Sensitive data field"
sub_type = "sensitive"
confidence = 0.75
cwe_ids = [312]
[patterns.match]
content_patterns = [
    # Require word boundary + assignment/declaration context to avoid matching
    # variable names, type names, module names, and pattern definition files.
    # Matches: password = "x", secret: "x", token := val, api_key => val
    # Does NOT match: token_count, SecretPattern, PasswordHasher, count_tokens
    "(?i)\\b(?:password|passwd|secret|api_key|apiKey|ssn|social_security)\\b\\s*(?:[:=]|=>|:=)\\s*[\"'`]",
    "(?i)\\b(?:credit_card|creditCard|card_number|cardNumber)\\b\\s*(?:[:=]|=>|:=)\\s*[\"'`]",
    "(?i)\\b(?:private_key|privateKey|encryption_key|encryptionKey)\\b\\s*(?:[:=]|=>|:=)\\s*[\"'`]",
    # Also catch struct/class field declarations with sensitive names that have a type annotation
    # Matches: password: String, secret: str, token: string
    # Does NOT match: token_count: usize, secret_pattern: Regex
    "(?i)\\b(?:password|passwd|secret|api_key|apiKey|ssn|social_security)\\b\\s*:\\s*(?:String|str|string|&str|&'static str|Vec<u8>|bytes|\\[u8\\])",
    "(?i)\\b(?:credit_card|creditCard|card_number|cardNumber)\\b\\s*:\\s*(?:String|str|string|&str)",
    "(?i)\\b(?:private_key|privateKey|encryption_key|encryptionKey)\\b\\s*:\\s*(?:String|str|string|&str|Vec<u8>|bytes|\\[u8\\])",
]
[patterns.match.not]
# Exclude pattern definition files, test fixtures, and token counter modules
file_patterns = ["**/patterns/**", "**/fixtures/**", "**/test*/**", "**/*token*counter*", "**/*tokeniz*"]
